package com.bw.fsm.expression_engine;

/**
 * Token variants, generated by Lexer.
 */
public abstract class Token<T> {

    public final TokenType type;
    public final T value;

    private Token(TokenType type, T value) {
        this.type = type;
        this.value = value;
    }

    /// Some constant number. Integer or float.
    public static abstract class NumericToken<V extends Number> extends Token<V> {

        private NumericToken(V value) {
            super(TokenType.Number, value);
        }

        public double as_double() {
            return this.value.doubleValue();
        }
    }

    public static class Integer extends NumericToken<java.lang.Integer> {

        public Integer(int value) {
            super(value);
        }

    }

    public static class Double extends NumericToken<java.lang.Double> {

        public Double(double value) {
            super(value);
        }
    }

    /// An identifier
    public static class Identifier extends Token<java.lang.String> {

        public Identifier(java.lang.String value) {
            super(TokenType.Identifier, value);
        }
    }

    /// Some constant string expression
    public static class TString extends Token<java.lang.String> {

        public TString(java.lang.String value) {
            super(TokenType.Identifier, value);
        }
    }

    /// A constant boolean expression.
    public static class Boolean extends Token<java.lang.Boolean> {

        public Boolean(java.lang.Boolean value) {
            super(TokenType.Boolean, value);
        }
    }

    /// Some operator
    public static class Operator extends Token<com.bw.fsm.expression_engine.Operator> {

        public Operator(com.bw.fsm.expression_engine.Operator value) {
            super(TokenType.Operator, value);
        }
    }

    /// Some bracket
    public static class Bracket extends Token<Character> {

        public Bracket(Character value) {
            super(TokenType.Bracket, value);
        }
    }

    /// A - none whitespace, none bracket - separator
    public static class Separator extends Token<Character> {

        public Separator(Character value) {
            super(TokenType.Separator, value);
        }
    }

    /// The expression separator to join multiple expressions.
    public static class ExpressionSeparator extends Token<Object> {

        private ExpressionSeparator() {
            super(TokenType.ExpressionSeparator, null);
        }

        public final static ExpressionSeparator INSTANCE = new ExpressionSeparator();
    }

    /// a Null value
    public static class Null extends Token<Object> {

        private Null() {
            super(TokenType.Null, null);
        }

        public final static Null INSTANCE = new Null();
    }

    /// Indicates a lexer error.
    public static class Error extends Token<String> {

        public Error(String message) {
            super(TokenType.Error, message);
        }
    }

    /// Indicates the end of the expression.
    public static class EOE extends Token<Object> {

        private EOE() {
            super(TokenType.EOE, null);
        }

        public final static EOE INSTANCE = new EOE();
    }
}
